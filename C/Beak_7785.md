```c

#include <stdio.h>
#include <stdbool.h> 
#include <stdlib.h>
#include <string.h>
//#include <malloc.h>

const int MAX_N = 1e6;
const int SIZE = 1 << 18;
const int STRLEM = 7;
int N, bcnt;


int strcmp(const char* s, const char* t) {
    while (*s && *s == *t) s++, t++;
    return *s - *t;
}

/* 
void strcpy(char* dest, const char* src) {
    while (*dest++ = *src++);
}
*/

struct member {
//    char names[STRLEM];
    char names[7];
    bool operator;
    /*
    bool operator <(const member& target) const {
        if (strcmp(names, target.names) > 0)
            return true;
        return false;
    }*/
};
// temp[1000000], arr[1000000]; //temp[MAX_N], arr[MAX_N];
 struct member* arr = NULL;
// struct member* temp =NULL;

 //typedef struct memb member;
//typedef struct memb  temp[1000000], arr[1000000];
 
//void mergeSort(struct member* arr, int s, int e) {
void mergeSort(int s, int e) {    
    if (s >= e) return;
 
    /////////////
    struct member* temp =NULL;
    //arr = (struct member*)malloc(sizeof(struct member)); //allocate memmory according to node struct size
    temp = (struct member*)malloc(sizeof(struct member)); //allocate memmory according to node struct size
    /////////////
    // 1. divide
    int m = (s + e) / 2;
 
    // 2. conquer
  //  mergeSort(arr, s, m);
  //  mergeSort(arr, m + 1, e);
    //////////////
    mergeSort( s, m);
    mergeSort( m + 1, e);
    ///////////////

    // 3. merge
    int i = s, j = m + 1, k;
    for (k = s; k <= e; ++k) {
        if (i > m) temp[k] = arr[j++];
        else if (j > e) temp[k] = arr[i++];
        //else if (arr[i] < arr[j]) temp[k] = arr[i++];
        else temp[k] = arr[j++];
    }
 
    // 4. copy
    for (i = s; i <= e; ++i) {
        arr[i] = temp[i];
    }
}
 
struct Node {
    char names[7];
    bool state;
    struct Node* next;
    /* 
    Node* alloc(char names[], Node *np) {
        strcpy(this->names, names); 
        state = true; 
        next = np;
        return this;
    }
    */
 
};//buf[1000000], *htab[262144]; //buf[MAX_N], *htab[SIZE];
///////////////
struct Node* buf[1000000]; // = NULL;
struct Node* *htab =NULL;
///////////////


int djb2(char* s) {
    int hash = 5381;
    for (; *s; ++s)
        hash = hash * 33 + *s;
    return hash % SIZE;
}
 
struct Node* probing(int hidx, char names[]) {
    struct Node* p = htab[hidx];
    for (; p ; p = p->next) {
        if (strcmp(p->names, names) == 0) {
            return p;
        }
    }
    return NULL;
}
 
int main() {
    // freopen("input.txt", "r", stdin);
    scanf("%d \n", &N);
    char names[7], state[7]; //names[STRLEM], state[STRLEM];

    ///////
    /*
    struct Node* malloc(char names[], struct Node *np) {
        strcpy(this->names, names); 
        state = true; 
        next = np;
        return this;
    }
    */
    ///////
    
    for (int i = 0; i < N; ++i) {
        scanf("%s %s \n", names, state);
 
        int hidx = djb2(names);
        struct Node* p = probing(hidx, names);
        if (strcmp(state, "enter") == 0) {
            // 기존에 존재하는 회사원인 경우 (출근 상태로 변경)
            if (p) p->state = true;
            // 새롭게 등록되는 회사원인 경우 (Hash Table에 추가)
            else  htab[hidx] = buf[bcnt++];//->malloc(names, htab[hidx]);
        }
        else { // leave
            // 등록된 회사원인 경우, 퇴근 상태로 변경
            if(p) p->state = false;
        }
    }
 
    // 출근 상태인 회사원 정보 추출
    int total = 0;
    for (int i = 0; i < bcnt; i++) {
        /*
        if (buf[i].state) {
            strcpy(arr[total++].names, buf[i].names);
        }*/
        if (buf[i]->state) {
            strcpy(arr[total++].names, buf[i]->names);
        }
    }
    
    // 역순 정렬
    //mergeSort(arr, 0, total - 1);
    mergeSort(0, total - 1);
 
    for (int i = 0; i < total; ++i) {
        printf("%s\n", arr[i].names);
    }
}
```
